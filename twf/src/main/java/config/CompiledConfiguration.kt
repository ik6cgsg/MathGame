package config

import expressiontree.*
import factstransformations.FactComporator
import factstransformations.FactSubstitution
import factstransformations.parseFromFactIdentifier
import platformdependent.toShortString

class CompiledConfiguration(
        val variableConfiguration: VariableConfiguration = VariableConfiguration(),
        val functionConfiguration: FunctionConfiguration = FunctionConfiguration(setOf("", "subfactorial")),
        val comparisonSettings: ComparisonSettings = ComparisonSettings(),
        val checkedFactAccentuation: CheckedFactAccentuation = CheckedFactAccentuation(),
        val factsLogicConfiguration: FactsLogicConfiguration = FactsLogicConfiguration(),
        var simpleComputationRuleParams: SimpleComputationRuleParams = SimpleComputationRuleParams(true),
        val gradientDescentComparisonConfiguration: GradientDescentComparisonConfiguration = GradientDescentComparisonConfiguration(),
        val additionalParamsMap: Map<String, String> = mapOf()) {
    val compiledImmediateVariableReplacements = mapOf<String, String>(*(variableConfiguration.variableImmediateReplacementRules.map { Pair(it.left, it.right) }.toTypedArray()))
    val compiledExpressionTreeTransformationRules = mutableListOf<ExpressionSubstitution>()
    val compiledExpressionSimpleAdditionalTreeTransformationRules = mutableListOf<ExpressionSubstitution>()
    val expressionTreeAutogeneratedTransformationRuledentifiers = mutableMapOf<String, ExpressionSubstitution>()
    val compiledFactTreeTransformationRules = mutableListOf<FactSubstitution>()
    val compiledImmediateTreeTransformationRules = mutableListOf<ExpressionSubstitution>()
    val compiledFunctionDefinitions = mutableListOf<ExpressionSubstitution>()
    val definedFunctionNameNumberOfArgsSet = mutableSetOf<String>()
    val noTransformationDefinedFunctionNameNumberOfArgsSet = mutableSetOf<String>()
    var configurationErrors = mutableListOf<ConfigurationError>()

    val factComporator: FactComporator

    fun parseStringExpression(expression: String, nameForRuleDesignationsPossible: Boolean = false): ExpressionNode? {
        val expressionTreeParser = ExpressionTreeParser(expression, nameForRuleDesignationsPossible, functionConfiguration, compiledImmediateVariableReplacements)
        val error = expressionTreeParser.parse()
        if (error != null) {
            configurationErrors.add(ConfigurationError(error.description, "TreeTransformationRule", expression, error.position))
            return null
        } else {
            return expressionTreeParser.root
        }
    }


    init {
        factComporator = FactComporator()
        factComporator.init(this)

        functionConfiguration.notChangesOnVariablesInComparisonFunction
                .forEach { definedFunctionNameNumberOfArgsSet.add(it.getIdentifier()) }

        functionConfiguration.notChangesOnVariablesInComparisonFunctionWithoutTransformations
                .forEach { noTransformationDefinedFunctionNameNumberOfArgsSet.add(it.getIdentifier()) }

        val compiledSubstitutions = mutableMapOf<String, ExpressionSubstitution>()
        for (functionDefinition in functionConfiguration.functionDefinitions) {
            val leftTree = parseStringExpression(functionDefinition.definitionLeftExpression, true)
            val rightTree = parseStringExpression(functionDefinition.definitionRightExpression, true)
            if (leftTree != null && rightTree != null) {
                if (leftTree.children.isEmpty() || rightTree.children.isEmpty()) {
                    configurationErrors.add(ConfigurationError("function definition rule is empty", "TreeTransformationRule",
                            "values: '" + functionDefinition.definitionLeftExpression + "' and '" + functionDefinition.definitionRightExpression + "'", -1))
                } else {
                    leftTree.variableReplacement(compiledImmediateVariableReplacements)
                    rightTree.variableReplacement(compiledImmediateVariableReplacements)
                    rightTree.applyAllFunctionSubstitutions(compiledSubstitutions)
                    val newSubstitution = ExpressionSubstitution(leftTree, rightTree)
                    compiledFunctionDefinitions.add(newSubstitution)
                    val definitionIdentifier = leftTree.children[0].value + "_" + leftTree.children[0].children.size
                    compiledSubstitutions.put(definitionIdentifier, newSubstitution)
                }
            }
        }

        for (treeTransformationRule in functionConfiguration.treeTransformationRules) {
            val leftTree = parseStringExpression(treeTransformationRule.definitionLeftExpression, true)
            val rightTree = parseStringExpression(treeTransformationRule.definitionRightExpression, true)
            if (leftTree != null && rightTree != null) {
                leftTree.variableReplacement(compiledImmediateVariableReplacements)
                rightTree.variableReplacement(compiledImmediateVariableReplacements)
                val newSubstitution = ExpressionSubstitution(leftTree, rightTree, treeTransformationRule.weight)
                if (treeTransformationRule.isImmediate) compiledImmediateTreeTransformationRules.add(newSubstitution)
                else {
                    compiledExpressionTreeTransformationRules.add(newSubstitution)
                    if (newSubstitution.simpleAdditional) {
                        compiledExpressionSimpleAdditionalTreeTransformationRules.add(newSubstitution)
                    }
                }
            }
        }

        for (treeTransformationRule in functionConfiguration.taskContextTreeTransformationRules) {
            val leftTree = parseStringExpression(treeTransformationRule.definitionLeftExpression, true)
            val rightTree = parseStringExpression(treeTransformationRule.definitionRightExpression, true)
            if (leftTree != null && rightTree != null) {
                leftTree.variableReplacement(compiledImmediateVariableReplacements)
                rightTree.variableReplacement(compiledImmediateVariableReplacements)
                val newSubstitution = ExpressionSubstitution(leftTree, rightTree, treeTransformationRule.weight, basedOnTaskContext = true)
                if (treeTransformationRule.isImmediate) compiledImmediateTreeTransformationRules.add(newSubstitution)
                else {
                    compiledExpressionTreeTransformationRules.add(newSubstitution)
                    if (newSubstitution.simpleAdditional) {
                        compiledExpressionSimpleAdditionalTreeTransformationRules.add(newSubstitution)
                    }
                }
            }
        }

        for (factTransformation in factsLogicConfiguration.factsTransformationRules) {
            val leftTree = parseFromFactIdentifier(factTransformation.definitionLeftFactTree, functionConfiguration = functionConfiguration)
            val rightTree = parseFromFactIdentifier(factTransformation.definitionRightFactTree, functionConfiguration = functionConfiguration)
            if (leftTree != null && rightTree != null) {
                leftTree.variableReplacement(compiledImmediateVariableReplacements)
                rightTree.variableReplacement(compiledImmediateVariableReplacements)
                compiledFactTreeTransformationRules.add(
                        FactSubstitution(leftTree, rightTree, factTransformation.weight, direction = factTransformation.direction, factComporator = factComporator)
                )
                if (!factTransformation.isOneDirection) {
                    compiledFactTreeTransformationRules.add(
                            FactSubstitution(rightTree, leftTree, factTransformation.weight, direction = factTransformation.direction, factComporator = factComporator)
                    )
                }
            }
        }

        if (additionalParamsMap.isNotEmpty()) {
            val simpleComputationRuleParamsMaxCalcComplexity = additionalParamsMap["simpleComputationRuleParamsMaxCalcComplexity"]?.toIntOrNull()
            if (simpleComputationRuleParamsMaxCalcComplexity != null) {
                simpleComputationRuleParams.maxCalcComplexity = simpleComputationRuleParamsMaxCalcComplexity
            }

            val simpleComputationRuleParamsMaxTenPowIterations = additionalParamsMap["simpleComputationRuleParamsMaxTenPowIterations"]?.toIntOrNull()
            if (simpleComputationRuleParamsMaxTenPowIterations != null) {
                simpleComputationRuleParams.maxTenPowIterations = simpleComputationRuleParamsMaxTenPowIterations
            }

            val simpleComputationRuleParamsMaxPlusArgRounded = additionalParamsMap["simpleComputationRuleParamsMaxPlusArgRounded"]?.toIntOrNull()
            if (simpleComputationRuleParamsMaxPlusArgRounded != null) {
                simpleComputationRuleParams.maxPlusArgRounded = simpleComputationRuleParamsMaxPlusArgRounded
            }

            val simpleComputationRuleParamsMaxPlusResRounded = additionalParamsMap["simpleComputationRuleParamsMaxPlusResRounded"]?.toIntOrNull()
            if (simpleComputationRuleParamsMaxPlusResRounded != null) {
                simpleComputationRuleParams.maxPlusResRounded = simpleComputationRuleParamsMaxPlusResRounded
            }

            val simpleComputationRuleParamsMaxMulArgRounded = additionalParamsMap["simpleComputationRuleParamsMaxMulArgRounded"]?.toIntOrNull()
            if (simpleComputationRuleParamsMaxMulArgRounded != null) {
                simpleComputationRuleParams.maxMulArgRounded = simpleComputationRuleParamsMaxMulArgRounded
            }

            val simpleComputationRuleParamsMaxMulResRounded = additionalParamsMap["simpleComputationRuleParamsMaxMulResRounded"]?.toIntOrNull()
            if (simpleComputationRuleParamsMaxMulResRounded != null) {
                simpleComputationRuleParams.maxMulResRounded = simpleComputationRuleParamsMaxMulResRounded
            }

            val simpleComputationRuleParamsMaxPowBaseRounded = additionalParamsMap["simpleComputationRuleParamsMaxPowBaseRounded"]?.toIntOrNull()
            if (simpleComputationRuleParamsMaxPowBaseRounded != null) {
                simpleComputationRuleParams.maxPowBaseRounded = simpleComputationRuleParamsMaxPowBaseRounded
            }

            val simpleComputationRuleParamsMaxPowDegRounded = additionalParamsMap["simpleComputationRuleParamsMaxPowDegRounded"]?.toIntOrNull()
            if (simpleComputationRuleParamsMaxPowDegRounded != null) {
                simpleComputationRuleParams.maxPowDegRounded = simpleComputationRuleParamsMaxPowDegRounded
            }

            val simpleComputationRuleParamsMaxPowResRounded = additionalParamsMap["simpleComputationRuleParamsMaxPowResRounded"]?.toIntOrNull()
            if (simpleComputationRuleParamsMaxPowResRounded != null) {
                simpleComputationRuleParams.maxPowResRounded = simpleComputationRuleParamsMaxPowResRounded
            }
        }
    }

    fun createExpressionFunctionNode (function: String, numberOfArgs: Int)
            = ExpressionNode(NodeType.FUNCTION, function, functionStringDefinition = functionConfiguration.fastFindStringDefinitionByNameAndNumberOfArguments(function, numberOfArgs))

    fun createExpressionVariableNode (value: Double)
            = if (value >= 0) {
        ExpressionNode(NodeType.VARIABLE, value.toShortString())
    } else {
        val plusNode = createExpressionFunctionNode("+", -1)
        plusNode.addChild(createExpressionFunctionNode("-", -1))
        plusNode.children.last().addChild(ExpressionNode(NodeType.VARIABLE, (-value).toShortString()))
        plusNode
    }
}